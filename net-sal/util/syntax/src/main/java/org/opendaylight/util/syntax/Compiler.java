/*
 * (c) Copyright 2004 Hewlett-Packard Co., All Rights Reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */

package org.opendaylight.util.syntax;

import java.util.Locale;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.StringTokenizer;
import java.lang.reflect.Constructor;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.DefaultHandler;

import org.opendaylight.util.syntax.parsers.NameValueParameterParser;
import org.opendaylight.util.syntax.parsers.TypedParser;
import org.opendaylight.util.syntax.parsers.ConstraintsParser;
import org.opendaylight.util.syntax.parsers.ParameterParser;
import org.opendaylight.util.syntax.parsers.StringParameterParser;
import org.opendaylight.util.syntax.parsers.StringListParameterParser;
import org.opendaylight.util.syntax.parsers.NumberParameterParser;
import org.opendaylight.util.syntax.parsers.NumberListParameterParser;
import org.opendaylight.util.syntax.parsers.DateParameterParser;
import org.opendaylight.util.syntax.parsers.DateListParameterParser;
import org.opendaylight.util.syntax.parsers.FileParameterParser;
import org.opendaylight.util.syntax.parsers.BooleanParameterParser;
import org.opendaylight.util.syntax.parsers.Utilities;

/**
 * Auxiliary class that provides the basic XML parsing capabilities.
 * 
 * @author Thomas Vachuska
 */
class Compiler extends DefaultHandler implements SyntaxKeywords {

    /**
     * Prefix constant indicating that a token in the usage string is a
     * reference to another node, rather than a keyword definition.
     */
    private static final String REFERENCE_PREFIX = "$";

    private Locale locale = Locale.US;

    /** Syntax package that will be created by this compiler. */
    private SyntaxPackage syntaxPackage = null;

    /** Currently processed syntax node. */
    private SyntaxNode currentNode = null;

    /** Stack of nested syntax nodes. */
    private List<SyntaxNode> stack = new ArrayList<SyntaxNode>();

    /**
     * Map of name->node bindings, used to keep track of not-yet resolved
     * syntax nodes.
     */
    private Map<String, SyntaxNode> nodes = new HashMap<String, SyntaxNode>();

    /**
     * Constructs the syntax compiler in the context of the given locale.
     * 
     * @param locale Locale context to use for compiling the otherwise
     *        locale-independent syntax.
     */
    public Compiler(Locale locale) {
        this.locale = locale;
    }

    /**
     * Resolve the syntax definitions generated by this compiler.
     * 
     * @return Syntax package or null if the compiler has not been subjected
     *         to XML parsing yet.
     */
    public SyntaxPackage resolveSyntax() {
        // Once the list of nodes is loaded, make a second pass to resolve
        // any inheritance aspects and to properly classify all the nodes.
        Iterator<String> it = nodes.keySet().iterator();
        while (it.hasNext()) {
            // Resolve each node and add it to the package.
            SyntaxNode node = nodes.get(it.next());
            syntaxPackage.addNode(resolve(node));
        }
        return syntaxPackage;
    }

    /**
     * Gets the specified XML attributes as a set of properties.
     * 
     * @param attributes XML Attributes to translate into set of properties.
     * @return Properties populated with the given attribute name/value
     *         bindings.
     */
    private Properties getProperties(Attributes attributes) {
        Properties p = new Properties();
        int length = attributes.getLength();
        for (int i = 0; i < length; i++) {
            String name = attributes.getLocalName(i);
            if (name == null || name.length() == 0)
                name = attributes.getQName(i);
            p.setProperty(name, attributes.getValue(i));
        }
        return p;
    }

    /**
     * Creates a syntax package instance using specified XML attributes.
     * 
     * @param attributes XML attributes of the syntax package node
     * @return newly created syntax package
     */
    private SyntaxPackage createPackage(Attributes attributes) {
        syntaxPackage = new SyntaxPackage(getProperties(attributes), locale);

        // Prime the package catalogues with builtin parsers.
        StringParameterParser stringParser = new StringParameterParser(locale);
        syntaxPackage.addParser(stringParser, ParameterParser.class);
        syntaxPackage.addParser(stringParser, ConstraintsParser.class);

        StringListParameterParser stringsParser = new StringListParameterParser(locale);
        syntaxPackage.addParser(stringsParser, ParameterParser.class);
        syntaxPackage.addParser(stringsParser, ConstraintsParser.class);

        NumberParameterParser numberParser = new NumberParameterParser(locale);
        syntaxPackage.addParser(numberParser, ParameterParser.class);
        syntaxPackage.addParser(numberParser, ConstraintsParser.class);

        NumberListParameterParser numbersParser = new NumberListParameterParser(locale);
        syntaxPackage.addParser(numbersParser, ParameterParser.class);
        syntaxPackage.addParser(numbersParser, ConstraintsParser.class);

        DateParameterParser dateParser = new DateParameterParser(locale);
        syntaxPackage.addParser(dateParser, ParameterParser.class);
        syntaxPackage.addParser(dateParser, ConstraintsParser.class);

        DateListParameterParser datesParser = new DateListParameterParser(locale);
        syntaxPackage.addParser(datesParser, ParameterParser.class);
        syntaxPackage.addParser(datesParser, ConstraintsParser.class);

        FileParameterParser fileParser = new FileParameterParser(locale);
        syntaxPackage.addParser(fileParser, ParameterParser.class);
        syntaxPackage.addParser(fileParser, ConstraintsParser.class);

        BooleanParameterParser booleanParser = new BooleanParameterParser(locale);
        syntaxPackage.addParser(booleanParser, ParameterParser.class);
        syntaxPackage.addParser(booleanParser, ConstraintsParser.class);

        NameValueParameterParser pairParser = new NameValueParameterParser(locale);
        syntaxPackage.addParser(pairParser, ParameterParser.class);
        syntaxPackage.addParser(pairParser, ConstraintsParser.class);

        return syntaxPackage;
    }

    /**
     * Creates a syntax parameter instance using specified XML attributes.
     * 
     * @param attributes XML attributes of the syntax parameter
     * @return newly created syntax parameter
     */
    private SyntaxNode createParameter(Attributes attributes) {
        return createNode(attributes, SyntaxParameter.class);
    }

    /**
     * Creates a fragment (or syntax) instance using specified XML attributes.
     * 
     * @param attributes XML attributes of the syntax fragment
     * @return newly created syntax fragment
     */
    private SyntaxNode createFragment(Attributes attributes) {
        return createNode(attributes, SyntaxFragment.class);
    }

    /**
     * Creates a node instance using specified XML attributes and a expected
     * class hint.
     * 
     * @param attributes XML attributes of the syntax node
     * @param classHint class of the expected type of the syntax node
     * @return newly created syntax node
     */
    private SyntaxNode createNode(Attributes attributes, Class<?> classHint) {
        return new SyntaxNode(currentNode, getProperties(attributes), locale,
                              classHint);
    }

    /**
     * Creates a name/value property and adds it to the list of properties
     * associated with the current node.
     * 
     * @param attributes XML attributes of the property
     */
    private void createProperty(Attributes attributes) {
        currentNode.getDB().setProperty(attributes.getValue(KW_NAME),
                                        attributes.getValue(KW_VALUE));
    }

    /**
     * Creates a parser instance using specified XML attributes.
     * 
     * @param attributes XML attributes of the parser definition
     * @param interfaceClass interface fulfilled by the parser
     * @return newly created parser instance
     */
    private TypedParser createParser(Attributes attributes,
                                     Class<?> interfaceClass) {
        TypedParser parser = null;
        String className = attributes.getValue(KW_CLASS);
        if (className != null) {
            parser = createParser(className);
            if (parser != null)
                syntaxPackage.addParser(parser, interfaceClass);
        }
        return parser;
    }

    /**
     * Creates a constraints parser instance using specified XML attributes.
     * 
     * @param className parser class
     * @return newly created parser instance
     */
    private TypedParser createParser(String className) {
        try {
            Class<?> classes[] = new Class[] { Locale.class };
            Object objects[] = new Object[] { locale };
            Class<?> parserClass = Class.forName(className);
            debug("got parser class: " + parserClass.getName());
            Constructor<?> constructor = parserClass.getConstructor(classes);
            debug("got constructor(Locale): " + constructor);
            return (TypedParser) constructor.newInstance(objects);

        } catch (ExceptionInInitializerError e) {
            throw new BadSyntaxException("Unable to create parser: " + e,
                                         currentNode);
        } catch (ClassNotFoundException e) {
            throw new BadSyntaxException("Unable to load parser class: " + e,
                                         currentNode);
        } catch (Exception e) {
            throw new BadSyntaxException("Unable to create parser: " + e,
                                         currentNode);
        }
    }

    /**
     * Returns the node whose name matches the specified name. Various
     * attempts are made to match the name with and without the name of the
     * container syntax node.
     * 
     * @param name node name
     * @param container syntax node where node is referenced
     * @return syntax node located using the specified name; null if none
     *         found
     */
    public SyntaxNode findNode(String name, SyntaxNode container) {
        String containerName = container.getName();

        // Is the name fully qualified? If not, attempt to resolve it into a
        // full name using the local scope of the given container.
        boolean fullyQualified = name.indexOf('.') > 0;
        String fullName = fullyQualified ? name : (containerName + "." + name);

        /** Can we find the node with this name? */
        SyntaxNode node = nodes.get(fullName);
        if (node != null)
            // Indeed we can! Most excellent! Return it!
            return node;

        else if (fullyQualified || container instanceof SyntaxPackage)
            // If the name was already fully qualified or the container
            // is a syntax package, lets' give up on further searches.
            return null;

        else
            // Otherwise, let's try one more time.
            return findNode(name, container.getContainer());
    }

    /**
     * Method performs post-load resolution of the given generic node and it
     * converts it to a specific syntax node instance.
     * 
     * @param node unresolved syntax node to be resolved to it's specific type
     * @return resolved syntax node instance
     */
    private SyntaxNode resolve(SyntaxNode node) {
        // Has this node been resolved yet? If so, bail.
        if (node.isResolved())
            return node;

        Properties db = node.getDB();
        SyntaxNode container = node.getContainer();

        SyntaxNode resolvedNode = null;
        SyntaxNodeExtension parent = null;

        // Check to see if this node is supposed to have a parent.
        String parentName = db.getProperty(KW_EXTENDS);
        if (parentName != null) {
            // If so, let's try to find it and then resolve it.
            SyntaxNode rawParent = findNode(parentName, container);
            if (rawParent != null)
                parent = (SyntaxNodeExtension) resolve(rawParent);
            else
                throw error("No parent node " + parentName + " for " + node,
                            node);
        }

        // If we don't have our own bundle, inherit one from our container.
        SyntaxNode scanContainer = container;
        ResourceBundle res = node.getResourceBundle();
        while (res == null && scanContainer != null) {
            res = scanContainer.getResourceBundle();
            scanContainer = scanContainer.getContainer();
        }

        if (res == null && parent != null)
            // If we still don't have our own bundle, inherit one from our
            // parent.
            res = parent.getResourceBundle();

        node.setResourceBundle(res);

        // Resolve the usage token list...
        List<SyntaxNode> anchoredNodes = null;
        List<SyntaxNode> floatingNodes = null;
        String usageString = db.getProperty(KW_USAGE);
        if (usageString != null) {
            anchoredNodes = new ArrayList<SyntaxNode>();
            floatingNodes = new ArrayList<SyntaxNode>();
            parseUsageString(node, parent, usageString, anchoredNodes,
                             floatingNodes);

        } else if (parent != null && parent instanceof SyntaxFragment) {
            // If this node did not have its own usage string, let's inherit
            // the node lists from the parent, if the node has one.
            anchoredNodes = ((SyntaxFragment) parent).getAnchoredNodes();
            floatingNodes = ((SyntaxFragment) parent).getFloatingNodes();
        }

        // Does this node have an action name or does it inherit one from its
        // parent?
        String actionName = db.getProperty(KW_ACTION_NAME);
        if (actionName != null)
            actionName = actionName.trim();
        if (actionName == null && parent != null && parent instanceof Syntax) {
            actionName = ((Syntax) parent).getActionName();
        }

        // Now we are ready to resolve the class of the node.
        if (anchoredNodes == null && floatingNodes == null) {
            // It is an syntax parameter leaf if it does not have a usage and
            // it does not inherit one from its parent.
            debug("anchored and floating are null, creating syntax parameter");
            resolvedNode = new SyntaxParameter(node, parent, syntaxPackage);

        } else if (actionName == null) {
            // It is a non-root syntax fragment if the node has a usage
            // string, but does not have a symbolic action, nor does it
            // inherit them.
            debug("no action name, creating syntax fragment");
            resolvedNode = new SyntaxFragment(node, parent, anchoredNodes,
                                              floatingNodes);
        } else {
            // It is a root syntax if the node has a usage string and a
            // symbolic action or if it inherits them.
            debug("defaulting to create a syntax");
            resolvedNode = new Syntax(node, parent, anchoredNodes,
                                      floatingNodes, actionName);
        }

        // Node is floating by default if it is a fragment and its anchored
        // nodes list is null or empty.
        boolean isFloating = (resolvedNode instanceof SyntaxFragment && (anchoredNodes == null
                || anchoredNodes.size() == 0 || (parent != null && parent
            .isFloating())));

        // Now see if there is a property to override the default.
        debug("checking for floating keyword; so far floating=" + isFloating);
        resolvedNode.setFloating(Utilities.get(db, KW_FLOATING, isFloating));
        debug("floating=" + resolvedNode.isFloating());

        // Make sure that if this is a floating extension, it's min
        // occurrences
        // are not 0; i.e. at least one.
        if (resolvedNode.isFloating()
                && ((SyntaxNodeExtension) resolvedNode).getMinOccurrences() < 1)
            throw error("Floating nodes must have minOccurrences >= 1.",
                        resolvedNode);

        // And finally replace the given node with the resolved one.
        nodes.put(resolvedNode.getName(), resolvedNode);
        return resolvedNode;
    }

    /**
     * Parses the specified usage string token list and populates the
     * specified anchored and floating nodes lists with references to other
     * nodes. If nodes are not found, it considers the token as a keyword.
     * 
     * @param node syntax node whose usage string is to be parsed
     * @param parent parent syntax node
     * @param tokenString node usage string
     * @param anchoredNodes list of parsed anchored nodes
     * @param floatingNodes list of parsed floating nodes
     */
    private void parseUsageString(SyntaxNode node, SyntaxNodeExtension parent,
                                  String tokenString,
                                  List<SyntaxNode> anchoredNodes,
                                  List<SyntaxNode> floatingNodes) {
        StringTokenizer st = new StringTokenizer(tokenString);
        String referencePrefix = REFERENCE_PREFIX;
        int referencePrefixLength = referencePrefix.length();
        while (st.hasMoreTokens()) {
            String token = st.nextToken();
            if (token.startsWith(referencePrefix)) {
                // Add the token as a syntax node...
                String nodeName = token.substring(referencePrefixLength);

                // Is it a super tag or a regular name reference tag?
                if (nodeName.equals(KW_SUPER)) {
                    // In case it's a super tag, import the floating and
                    // anchored tokens. The burden is placed upon the
                    // developer to ensure that there is a distinction
                    // between supernode and subnode.
                    if (parent != null && parent instanceof SyntaxFragment) {
                        List<SyntaxNode> floaters = ((SyntaxFragment) parent)
                            .getFloatingNodes();
                        if (floaters != null)
                            floatingNodes.addAll(floaters);

                        List<SyntaxNode> anchors = ((SyntaxFragment) parent)
                            .getAnchoredNodes();
                        if (anchors != null)
                            anchoredNodes.addAll(anchors);
                    }

                } else {
                    // If it is a name reference, let's find the object
                    // associated with that name.
                    SyntaxNode referencedNode = findNode(nodeName, node);
                    if (referencedNode != null) {
                        // Make sure the node is resolved.
                        SyntaxNode resolvedNode = resolve(referencedNode);

                        // And then add the node to the appropriate list.
                        if (resolvedNode.isFloating())
                            floatingNodes.add(resolvedNode);
                        else
                            anchoredNodes.add(resolvedNode);
                    } else {
                        throw error("Unable to resolve " + node, node);
                    }
                }

            } else {
                // It does not begin with a reference prefix to it must be a
                // keyword.
                anchoredNodes.add(new SyntaxKeyword(token, node, locale));
            }
        }
    }

    @Override
    public void startElement(String namespaceURI, String localName,
                             String qName, Attributes attributes)
                          throws SAXException {
        String name = qName == null || qName.length() == 0 ? localName : qName;
        if (name.equals(KW_PACKAGE)) {
            stack.add(0, currentNode);
            currentNode = createPackage(attributes);

        } else if (name.equals(KW_SYNTAX)) {
            // Push the current fragment on the stack of nested nodes.
            stack.add(0, currentNode);
            currentNode = createFragment(attributes);

        } else if (name.equals(KW_PARAMETER)) {
            stack.add(0, currentNode);
            currentNode = createParameter(attributes);

        } else if (name.equals(KW_PROPERTY)) {
            createProperty(attributes);

        } else if (name.equals(KW_CONSTRAINTS_PARSER)) {
            createParser(attributes, ConstraintsParser.class);

        } else if (name.equals(KW_PARAMETER_PARSER)) {
            createParser(attributes, ParameterParser.class);

        } else {
            throw error("Incorrect XML tag [" + name + "]", currentNode);
        }
    }

    @Override
    public void endElement(String namespaceURI, String localName, String qName)
                    throws SAXException {
        String name = qName == null || qName.length() == 0 ? localName : qName;
        if ((name.equals(KW_SYNTAX) || name.equals(KW_PARAMETER))
                && stack.size() > 0) {
            // Pop the stack of nested nodes.
            if (nodes.containsKey(currentNode.getName()))
                throw error("Duplicate syntax node name: " + 
                            currentNode.getName(), currentNode);
            nodes.put(currentNode.getName(), currentNode);
            currentNode = stack.remove(0);
        }
    }

    @Override
    public void error(SAXParseException e) throws SAXException {
        throw e;
    }

    /**
     * Generate and return an instance of {@link BadUsageException} using the
     * given message and node.
     * 
     * @param message exception message string
     * @param node syntax node that caused the exception
     * @return new bad syntax exception
     */
    private BadSyntaxException error(String message, SyntaxNode node) {
        return new BadSyntaxException(message, node);
    }

    public static void debug(Object message) {
        if (System.getenv("DEBUG") != null)
            System.err.println(message);
    }
}

/*
 * Copyright (c) 2014 Brocade Communications Systems Inc and others. All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */
package org.opendaylight.openflowplugin.openflow.md.core.sal.convertor;

import java.math.BigInteger;
import java.util.Arrays;
import org.junit.Assert;
import org.junit.Test;
import org.opendaylight.openflowjava.util.ByteBufUtils;
import org.opendaylight.openflowplugin.openflow.md.core.sal.convertor.match.MatchConvertorUtil;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.Ipv6Address;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.Ipv6Prefix;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.yang.types.rev130715.DottedQuad;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Anton Ivanov aivanov@brocade.com
 * @author Sai MarapaReddy sai.marapareddy@gmail.com
 *
 */
public class IpConversionUtilTest {

    private static Logger LOG = LoggerFactory
            .getLogger(IpConversionUtilTest.class);



    /*
     * Test canonicalBinaryV6Address
     */
    @Test
    public void canonicalBinaryV6AddressTest() {

        byte [] ipv6binary = IpConversionUtil.canonicalBinaryV6Address(new Ipv6Address("0000:0000:0000:0000:0000:0000:0000:0001"));
        byte [] expected = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,1};

        Assert.assertTrue("Incorrect canonicalization - binary", Arrays.equals(ipv6binary, expected));
        try {
            Assert.assertEquals("Incorrect canonicalization - string", "::1", IpConversionUtil.byteArrayV6AddressToString(ipv6binary));
        } catch (java.net.UnknownHostException e) {
            Assert.assertTrue("Incorrect canonicalization - wrong length of byte[]", false);
        }
    }

    /*
     * Test canonicalBinaryV6Prefix
     */
    @Test
    public void canonicalBinaryV6AddressPrefixTest() {

        byte [] ipv6binary = IpConversionUtil.canonicalBinaryV6Prefix(new Ipv6Prefix("0000:0000:0000:0000:0000:0000:0000:0001/64"));
        byte [] expected = {0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 64};

        Assert.assertTrue("Incorrect canonicalization - binary", Arrays.equals(ipv6binary, expected));
        try {
            Assert.assertEquals("Incorrect canonicalization - string", "::/64", IpConversionUtil.byteArrayV6PrefixToString(ipv6binary));
        } catch (java.net.UnknownHostException e){
            Assert.assertTrue("Incorrect canonicalization - wrong length of byte[]", false);
        }
    }

    @Test
    public void testCountBitsAsCIDRReplacement() throws Exception {
        BigInteger maskSeed = new BigInteger("1ffffffffffffffffffffffffffffffff", 16);
        byte[] maskArray = new byte[16];
        LOG.debug("maskSeed= {}", ByteBufUtils.bytesToHexString(maskSeed.toByteArray()));

        for (int i = 0; i <= 128; i++) {
            System.arraycopy(maskSeed.toByteArray(), 1, maskArray, 0, 16);
            LOG.debug("maskHex[{}] = {}", i, ByteBufUtils.bytesToHexString(maskArray));
            int cidr = IpConversionUtil.countBits(maskArray);
            LOG.debug("cidr = {}", cidr);
            Assert.assertEquals(128 - i, cidr);

            maskSeed = maskSeed.clearBit(i);
        }
    }


    /**
     * Test method for {@link MatchConvertorUtil#getIpv4Mask(byte[])}.
     *
     * @throws Exception
     */

    @Test
    public void testcountBitsAsGetIpv4Mask() {
        byte[][] maskInputs = new byte[][]{
                {(byte) 255, (byte) 255, (byte) 255, (byte) 255},
                {(byte) 255, (byte) 255, (byte) 254, 0},
                {(byte) 128, 0, 0, 0},
                {0, 0, 0, 0},
        };

        int[] maskOutputs = new int[]{
                32, 23, 1, 0
        };

        for (int i = 0; i < maskInputs.length; i++) {
            int mask = IpConversionUtil.countBits(maskInputs[i]);
            Assert.assertEquals(maskOutputs[i], mask);
        }
    }

    @Test
    public void convertArbitraryMaskToByteArrayTest() {
        int value = 0xffffffff;
        byte[] bytes = new byte[]{
                (byte)(value >>> 24), (byte)(value >> 16 & 0xff), (byte)(value >> 8 & 0xff), (byte)(value & 0xff) };
        byte[] maskBytes;
        maskBytes = IpConversionUtil.convertArbitraryMaskToByteArray(new DottedQuad("255.255.255.255"));
        for(int i=0; i<bytes.length;i++){
            int mask = maskBytes[i];
            Assert.assertEquals(bytes[i],mask);
        }
    }

    @Test
    public void isArbitraryBitMaskTest() {
        boolean arbitraryBitMask;
        arbitraryBitMask = IpConversionUtil.isArbitraryBitMask(new byte[] {1,1,1,1});
        Assert.assertEquals(arbitraryBitMask,true);
        arbitraryBitMask = IpConversionUtil.isArbitraryBitMask(new byte[] {-1,-1,-1,-1});
        Assert.assertEquals(arbitraryBitMask,false);
        arbitraryBitMask = IpConversionUtil.isArbitraryBitMask(new byte[] {-1,-1,0,-1});
        Assert.assertEquals(arbitraryBitMask,true);
        arbitraryBitMask = IpConversionUtil.isArbitraryBitMask(null);
        Assert.assertEquals(arbitraryBitMask,false);
    }
}

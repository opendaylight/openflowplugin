{
  "comments": [
    {
      "key": {
        "uuid": "ba51214e_eda9cd7c",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 79,
      "author": {
        "id": 527
      },
      "writtenOn": "2016-06-14T01:58:40Z",
      "side": 1,
      "message": "It is better to close listener registration when FlowCapableInventoryProvider.close() is called.",
      "range": {
        "startLine": 79,
        "startChar": 35,
        "endLine": 79,
        "endChar": 51
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51214e_21bbd4c5",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 527
      },
      "writtenOn": "2016-06-13T12:27:00Z",
      "side": 1,
      "message": "I am worried that this will cause the issue described in bug 5974. onNoedRemoved() will be called twice for the same switch if OF plugin publishes node-removed notification.\n\nI think it is better to ignore node-removed notification published by OF plugin.",
      "range": {
        "startLine": 242,
        "startChar": 25,
        "endLine": 242,
        "endChar": 26
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51214e_cdc32989",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 527
      },
      "writtenOn": "2016-06-14T00:48:42Z",
      "side": 1,
      "message": "In my understanding, OF plugin obtains entity ownership for OF session irrespective of cluster configuration. So I think ownershipChanged() will be called when a OF session is disconnected even if OF-HA is not configured. Is this correct?\nIf correct, when OF session is disconnected and OF-HA is not configured for that session, onNodeRemoved() will be called twice for that session (one is a call from here, and another is node-removed notification). That is why I think we can simply ignore node-removed notification published by OF plugin because ownershipChanged() will remove node from operational DS when OF session is destroyed, even in case where OF-HA is not configured.",
      "parentUuid": "ba51214e_a1ac0437",
      "range": {
        "startLine": 242,
        "startChar": 25,
        "endLine": 242,
        "endChar": 26
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51214e_4d9559e3",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 527
      },
      "writtenOn": "2016-06-14T02:45:01Z",
      "side": 1,
      "message": "I understand what you intend. But this code will be executed when a switch goes down. If a switch is connected (without OF-HA) to a single node clustered controller, and that switch goes down, then ownershipChanged() will be called on that controller with an EntityOwnershipChange(wasOwner\u003dtrue, isOwner\u003dfalse, hasOwner\u003dfalse).",
      "parentUuid": "ba51214e_c1af782a",
      "range": {
        "startLine": 242,
        "startChar": 25,
        "endLine": 242,
        "endChar": 26
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51214e_fb504e60",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 65
      },
      "writtenOn": "2016-06-17T08:19:02Z",
      "side": 1,
      "message": "I think to address Shigeru\u0027s comment, we should call onNodeRemove, when following condition is true deletedNodeCache.getIfPresent(node.getNodeRef()) \u003d\u003d null\n\nif plugins OnNodeRemoved is received first, above condition will avoid another call on ownership change, but if plugin\u0027s onNodeRemove call received after entityOnwershipChange notification, it will result in two calls, but second call will be ignored because of the following condition\n\nif (deletedNodeCache.getIfPresent(node.getNodeRef()) \u003d\u003d null) {\n            deletedNodeCache.put(node.getNodeRef(), Boolean.TRUE);\n        } else {\n            //its been noted that creating an operation for already removed node, fails\n            // the entire transaction chain, there by failing deserving removals\n            LOG.debug(\"Already received notification to remove node, {} - Ignored\",\n                    node.getNodeRef().getValue());\n            return;\n        }\n\nthoughts?",
      "parentUuid": "ba51214e_62d30739",
      "range": {
        "startLine": 242,
        "startChar": 25,
        "endLine": 242,
        "endChar": 26
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51214e_7e20a2f7",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 527
      },
      "writtenOn": "2016-06-21T11:05:19Z",
      "side": 1,
      "message": "It seems to work fine if single node cluster.\nIf 3-node cluster, onNodeRemoved() will be called on all the controllers in the cluster. For example, OF switch connected to 3-node clustered controller goes down, entity ownership change will be notified to all the controllers in the cluster. So all the controllers will try to delete the same node from oper DS almost simultaneously. Would not this cause any problem?",
      "parentUuid": "ba51214e_fb504e60",
      "range": {
        "startLine": 242,
        "startChar": 25,
        "endLine": 242,
        "endChar": 26
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51214e_c1af782a",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 8051
      },
      "writtenOn": "2019-11-04T22:11:05Z",
      "side": 1,
      "message": "Hi Shigeru,\n\nThis is a very specific scenario, in which the openflow switch is removed only if isOwner and hasOwner is false.\nThe scenario can occur if the controller node that is connected to the switch goes down(in a non-OFHA scenario) thereby causing the switch to remain in the oper-DS.",
      "parentUuid": "ba51214e_21bbd4c5",
      "range": {
        "startLine": 242,
        "startChar": 25,
        "endLine": 242,
        "endChar": 26
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51214e_a1ac0437",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 7865
      },
      "writtenOn": "2019-11-12T23:22:49Z",
      "side": 1,
      "message": "You mean that we leave the switch data to be present in OPer DS ? In cases where OF-HA is not being used AND the cluster-node where switch is connected is rebooted, Oper DS will still contain switch info. Now, when switch reconnects to the same cluster-node or different cluster-node, even if we try to update Oper DS, DataTreeChange notification would not be fired (because we are updating same switch infor again) and hence reconciliation would not trigger. \nDo you agree with the above issue ?",
      "parentUuid": "ba51214e_21bbd4c5",
      "range": {
        "startLine": 242,
        "startChar": 25,
        "endLine": 242,
        "endChar": 26
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ba51214e_62d30739",
        "filename": "applications/inventory-manager/src/main/java/org/opendaylight/openflowplugin/applications/inventory/manager/NodeChangeCommiter.java",
        "patchSetId": 6
      },
      "lineNbr": 242,
      "author": {
        "id": 7865
      },
      "writtenOn": "2019-11-12T23:22:49Z",
      "side": 1,
      "message": "I agree with your point. We are having a brief design discussion to see if its possible to address this disparate issues in a more elegant manner. I guess, for now, we can hold back this patch",
      "parentUuid": "ba51214e_4d9559e3",
      "range": {
        "startLine": 242,
        "startChar": 25,
        "endLine": 242,
        "endChar": 26
      },
      "revId": "cdf6d8073bf006b24a5bd9a72b97439ccd2f250b",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}